var displayData = {};
var paramData = [];
var responseData = [];

/* Extracts Data to be displayed on Mapping Page */

async function extractData(path, spec) {

    
    //Extract Description
    if (spec.info.description !== undefined) {
        displayData["description"]= spec.info.description;
    }
    else {
        displayData["description"]= ""
    }

    var returnExtractPathsAndMethods = await extractPathsAndMethods(path, spec);
    if (returnExtractPathsAndMethods) {
        //console.log("End Result ::: ",JSON.stringify(returnExtractPathsAndMethods));
        return returnExtractPathsAndMethods
    }

   // return returnExtractPathsAndMethods
}


//This function gets all paths and methods from a JSON API Swagger Documentation
async function extractPathsAndMethods(specPaths, spec) {

    displayData["operations"] = [];
    var paths = Object.keys(specPaths);
    var methods;
    var albatross
    var paramVal;
    var operationId;
    // Iterate to get all Methods for each and every path
    for (var i = 0; i < paths.length; i++) {
        methods = Object.keys(spec.paths[paths[i]]);

        // Iterate to get all Parameters for each Method
        for (var j = 0; j < methods.length; j++) {
            if(typeof spec.paths[paths[i]][methods[j]].operationId !== undefined){
                operationId = spec.paths[paths[i]][methods[j]].operationId;
            } else {
                operationId = "";
            }
            
            // // Check whether parameters exists inside Responses
            // var responses  = Object.keys(spec.paths[paths[i]][methods[j]].responses);
            // // console.log(responses);
            // if (spec.paths[paths[i]][methods[j]].responses['200']!==undefined){
            //     if(spec.paths[paths[i]][methods[j]].responses['200'].schema!==undefined)
            //         // console.log("Success: ",spec.paths[paths[i]][methods[j]].responses['200'].schema.properties);
            //         //Remove Extra Values and convert back to JSON Tree
                   
            //         var returnRemoveExtraProperties;
            //         if(spec.paths[paths[i]][methods[j]].responses['200'].schema.properties!==undefined){

            //            var  flattenedValues =  await flatten(spec.paths[paths[i]][methods[j]].responses['200'].schema.properties);
            //              //console.log("Display Dat :: ",abyss);
            //                  returnRemoveExtraProperties= await removeExtraProperties(flattenedValues);

            //         }else if(spec.paths[paths[i]][methods[j]].responses['200'].schema.items!==undefined){

            //             var  flattenedValues =  await flatten(spec.paths[paths[i]][methods[j]].responses['200'].schema.items);
                         
            //                  returnRemoveExtraProperties= await removeExtraProperties(flattenedValues);
            //                 //  console.log("Inside Items :: ",returnRemoveExtraProperties);
            //         }
            
            //                // var returnRemoveExtraProperties= await removeExtraProperties(flattenedValues);
            
            //                 if(returnRemoveExtraProperties){
                                
            //                     var schemaData = await formHierarchy(returnRemoveExtraProperties)
            //                     // console.log("Response Data : ",JSON.stringify(schemaData));
            //                     responseData.push({'200':schemaData});
                                
            //                 }
            // }

            // Check whether parameter exists or not inside method
            if (spec.paths[paths[i]][methods[j]].parameters !== undefined && spec.paths[paths[i]][methods[j]].parameters.length !== 0) {
                var parameters = spec.paths[paths[i]][methods[j]].parameters;
                
                // Extract Responses
                var  responseValues = spec.paths[paths[i]][methods[j]].responses;
                console.log(responseValues.length," ::: Responses Values ::: ",responseValues);
                var responseVal = await extractResponse(responseData,responseValues);
                console.log("Response Values ::", responseVal)
                // Extract Responses Ends Here

                for (var k = 0; k < parameters.length; k++) {
                   
                    // Search for Mandatory fields
                       

                    if (spec.paths[paths[i]][methods[j]].parameters[k].schema !== undefined) {
                        //getNames(paths[i], methods[j], spec.paths[paths[i]][methods[j]].parameters[k].schema)
                        paramVal = spec.paths[paths[i]][methods[j]].parameters[k].schema.properties;
                        //paramData.push(paramVal);


                        //Remove Extra Values and convert back to JSON Tree
                        var flattenedValues =  await flatten(paramVal)

                        
                        //console.log("Display Dat :: ",abyss);
                        var returnRemoveExtraProperties= await removeExtraProperties(flattenedValues);
                        
                        if(returnRemoveExtraProperties){
                            
                            var schemaData = await formHierarchy(returnRemoveExtraProperties)
                            //console.log("Returned Data : ",JSON.stringify(schemaData));
                            paramData.push(schemaData);
                        }

                        /* Remove extra values such as xml etc. */
                        //albatross = await removeAdditionalValues(paramVal);

                        //await readDocument(paths[i], methods[j], spec.paths[paths[i]][methods[j]].parameters)
                    } else {

                        //console.log(parameters[l])
                        var paramVal = spec.paths[paths[i]][methods[j]].parameters[k].name;
                        var required = spec.paths[paths[i]][methods[j]].parameters[k].required;
                        var location = spec.paths[paths[i]][methods[j]].parameters[k].in;
                        var type = spec.paths[paths[i]][methods[j]].parameters[k].type?spec.paths[paths[i]][methods[j]].parameters[k].type:"";
                        var params = JSON.parse("{\""+paramVal+"\":"+"{\"type\":"+"\""+type+"\",\"in\":"+"\""+location+"\",\"required\":"+"\""+required+"\"}}");

//Incase required is needed
//var params = JSON.parse("{\""+paramVal+"\":"+"{\"type\":"+"\""+type+"\","+"\"required\":"+"\""+required+"\"}}");
                        paramData.push(params);
                    }
                }
                displayData["operations"].push({operationId: operationId, path: paths[i], method: methods[j], fields: paramData, responses:responseData});
                paramData = [];
                responseData = [];
            } else {
                // esqlData.push(paths[i] + ":" + methods[j] + ":")
                displayData["operations"].push({operationId: operationId, path: paths[i], method: methods[j], fields: ""});
                var parameters = spec.paths[paths[i]];
                
            }
        }

    }
    // esqlData = await getUnique(esqlData);
    // esqlData = await transformEachRecord(esqlData);
    // if(albatross)
    return displayData;
}

//Get Names for all Parameters from methods
function getNames(path, method, array) {
    for (var i = 0; i < array.length; i++) {
        if (typeof array[i].type !== "undefined") {
            esqlData.push(path + ":" + method + ":" + array[i].name + "." + array[i].type);
        }
    }
    return esqlData;
}

async function getParameters(schema){

}

/* Remove Values */

async function removeAdditionalValues(obj) {

    //    treeLevel = parseInt(treeLevel) + 1;
    for (const i in obj) {

        if (typeof obj[i] === 'object' || Array.isArray(obj[i])) {
            var type = obj[i]["type"]
            await removeAdditionalValues(obj[i]);
        } else {
            var typeOfObject = obj[i].toString();
            if (!(typeOfObject === "object" || typeOfObject === "array" || typeOfObject.includes("#/definitions") || typeOfObject.indexOf(' ') >= 0 || typeof type === "undefined")) {
                // jsonSourceArray.push(path + ":" + method + ":" + "JSON.Data" + indent.trim() + "." + type);
                //console.log("SHOW DATA ::: ", obj[i])
            }
        }
    }
    return "jsonSourceArray";
}


async function flatten(data) {
    var result = {};
    function recurse (cur, prop) {
        if (Object(cur) !== cur) {
            result[prop] = cur;
           // console.log("Flatten :",result[prop]);
        } else if (Array.isArray(cur)) {
             for(var i=0, l=cur.length; i<l; i++)
                 recurse(cur[i], prop + "[" + i + "]");
            if (l == 0)
                result[prop] = [];
        } else {
            var isEmpty = true;
            for (var p in cur) {
                isEmpty = false;
                recurse(cur[p], prop ? prop+"."+p : p);
            }
            if (isEmpty && prop)
                result[prop] = {};
        }
    }
    
    recurse(data, "");
    return result;
}


async function removeExtraProperties(data){
    //Check for converting JSON to Array {} - [] for forward
    //console.log("Whole Data : ",data)
    var dataKeys = Object.keys(data);
    var eachValue ;
    var returnData = {};
    var dataType;
    //console.log("Remove Array ::: ",Object.keys(data));
    for(var eachKey of dataKeys){
        eachValue = eachKey;
        //console.log("EACH  ::: ",eachValue)
        if(eachValue.endsWith("type") || eachValue.endsWith("format")){
           
            dataType = data[eachKey];
        //    console.log(eachValue," :::: ",dataType)
            returnData[eachValue] = dataType
            //console.log("SHOW REturn Data LL ",returnData)
        }
        else {
           // console.log("Inside Else :: ",data[eachKey])
        }
    }
    /* If an object is an array the datatype catches object 
       instead of array due to the array consisting 'items' keyword 
       which contains object */
    //Below code is commented as we want to send all the details of a request parameter. 13092019
    // return await removeParameterAndItem(returnData);
    return returnData;
}

/* UnFlatten JSON Data */
async function formHierarchy(data) {
    "use strict";
    if (Object(data) !== data || Array.isArray(data))
        return data;
    var regex = /\.?([^.\[\]]+)|\[(\d+)\]/g,
        resultholder = {};
    for (var p in data) {
        var cur = resultholder,
            prop = "",
            m;
        while (m = regex.exec(p)) {
            cur = cur[prop] || (cur[prop] = (m[2] ? [] : {}));
            prop = m[2] || m[1];
        }
        cur[prop] = data[p];
    }
    return resultholder[""] || resultholder;
};

async function extractResponse(responseData,responseValues){
    for (var l in responseValues) {

        // console.log(l," ::: Show Data Respnses :::",responseValues[l])
        if (responseValues[l]!==undefined && responseValues[l].schema !== undefined) {
            paramVal = responseValues[l].schema;
            // console.log(responseValues[l]," :::: Show Data Respnses Inside :::", paramVal);
            if(responseValues[l].schema.items!==undefined){
                // console.log("Internal Data : : ",responseValues[l].schema.items)
                paramVal = await flatten(responseValues[l].schema.items);
            }else if (responseValues[l].schema.properties!==undefined){
                // console.log("Internal Data : : ",responseValues[l].schema.properties);
                paramVal = await flatten(responseValues[l].schema.properties);
            }else{
                // console.log("Internal Data : : ",responseValues[l].schema);
                paramVal = await flatten(responseValues[l].schema.properties)
            }

             //paramVal = await flatten(responseValues[l].schema);
            // console.log(paths[i],":: Flattened Internal :::",paramVal);
             returnRemoveExtraProperties= await removeExtraProperties(paramVal);
             if(returnRemoveExtraProperties){
                var schemaData = await formHierarchy(returnRemoveExtraProperties)
                responseData.push({[l]:schemaData});
             }
            //  console.log(l," :: Show Data Response ::: ",returnRemoveExtraProperties);
             
        }

    }
    return responseData;
}

async function removeParameterAndItem(jsonObject) {
    var eachRecord;
    var jsonObj
    var cleanData = {};
    var uncleanData = [];

    //console.log("Full JSON Object ::: ",jsonObject)
    // jsonObject has all the data

   jsonObj = Object.keys(jsonObject);
    //console.log("Show JSON Object ::: ",jsonObject)
    for (var data of jsonObj) {
      //  console.log(" :: Each Data Object :: ",data)
        eachRecord = data.split(".");
        for (var j = 0; j < eachRecord.length; j++) {
            if (eachRecord[j] === eachRecord[j + 1]) {
                if (eachRecord[j] === "properties") {
                    //console.log("Show inside Data Node")
                    eachRecord.splice(parseInt(j+1), 1);
                }

            } else {
                if (eachRecord[j] === "properties" ) {
                    eachRecord.splice(j, 1);
                    j = j - 1;
                }
            }         
        }

        values = eachRecord.join('.')
        //console.log(data ,":: Each Value Data :: ",jsonObject[data])
        //console.log(": j j+1 :")
        //console.log(jsonObject[data],"::: SHOW VALUES L LLLLL  LLL :::",values)
        if(cleanData[values]!=undefined){
           // console.log(cleanData[values],"::: Inside clean duplicate :::: ",values);
           // console.log(data," : Display Data : ",jsonObject[data]);
            //cleanData[values].concat(jsonObject[data]);
            /* Check the code.. changes need to be done. For eg: transactions.items.properties.item_list.properties.items.type 
            changes to transactions.item_list.type which is a different data. */
            cleanData[values] = jsonObject[data];
           // console.log(values,"After value",cleanData[values])
        }
        else{
            cleanData[values] = jsonObject[data];
        }
    }
    //console.log("Clean Data ::: ",cleanData)
    return cleanData;
}
module.exports.extractData = extractData;