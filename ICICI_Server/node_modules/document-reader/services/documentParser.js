var esqlData = [];
var jsonDataArr = {}


//This function gets all paths and methods from a JSON API Swagger Documentation
async function extractPathsAndMethods(specPaths, spec) {

    var paths = Object.keys(specPaths);
    var methods;
    
    // Iterate to get all Methods for each and every path
    for (var i = 0; i < paths.length; i++) {
        methods = Object.keys(spec.paths[paths[i]]);
        
        // Iterate to get all Parameters for each Method
        for (var j = 0; j < methods.length; j++) {
            // Check whether parameter exists or not inside method
            if (spec.paths[paths[i]][methods[j]].parameters !== undefined && spec.paths[paths[i]][methods[j]].parameters.length !== 0) {
                var parameters = spec.paths[paths[i]][methods[j]].parameters;

                for (var k = 0; k < parameters.length; k++) {
                    if (spec.paths[paths[i]][methods[j]].parameters[k].schema !== undefined) {
                        getNames(paths[i], methods[j], spec.paths[paths[i]][methods[j]].parameters[k].schema)
                        await readDocument(paths[i], methods[j], spec.paths[paths[i]][methods[j]].parameters)
                    } else {
                        getNames(paths[i], methods[j], spec.paths[paths[i]][methods[j]].parameters)
                    }
                }
            } else {
                esqlData.push(paths[i] + ":" + methods[j] + ":")
            }
        }

    }
    esqlData = await getUnique(esqlData);
    esqlData = await transformEachRecord(esqlData);
    return esqlData;
}

//Get Names for all Parameters from methods
function getNames(path, method, array) {
    for (var i = 0; i < array.length; i++) {
        if (typeof array[i].type !== "undefined") {
            esqlData.push(path + ":" + method + ":" + array[i].name + "." + array[i].type);
        }
    }
    return esqlData;
}


/*
Removes duplicate values
array - Parameter
*/
async function getUnique(array) {
    var uniqueArray = [];
    var splitValue;
    // Loop through array values and remove duplicate values
    for (i = 0; i < array.length; i++) {
        if (uniqueArray.indexOf(array[i]) === -1) {
            splitValue = array[i].toString().split(":");
            if (splitValue[2] === "JSON.Data") {} else {
                uniqueArray.push(array[i]);
            }
        }
    }
    uniqueArray.sort();
    return uniqueArray;
}

// ----------------------------READ Document--------------------------------
var jsonTree = 0;
var values = [];
var jsonSourceArray = [];


// Will extract Schema Data from API Request in case of PUT & POST Request
async function readDocument(path, method, jsonSource) {
    //Checks whether schema exists or not inside jsonSource
    if (jsonSource != undefined && jsonSource.hasOwnProperty('schema')) {
        jsonSource = jsonSource.schema.properties;
    } else {
        jsonSource = jsonSource;
    }

    var jsonSourceValue = await readJSONAndAssignLevels(path, method, jsonSource, '', 'method', jsonTree)
    if (jsonSourceValue) {
        //removeParameterAndItem removes properties and items that are not required
        var returnRemoveParameterAndItem = await removeParameterAndItem(jsonSourceValue);
        if (returnRemoveParameterAndItem) {
            var unique = await getUnique(returnRemoveParameterAndItem)
            return unique;
        }

    }
    // return unique;
}

async function readJSONAndAssignLevels(path, method, obj, indent, value, treeLevel, type) {
    if (obj != undefined && obj.hasOwnProperty('schema')) {
        if (typeof obj.schema.properties !== "undefined") {
            obj = obj.schema.properties;
        } else {
            obj = obj.schema;
        }
    }
    treeLevel = parseInt(treeLevel) + 1;
    for (const i in obj) {

        if (typeof obj[i] === 'object' || Array.isArray(obj[i])) {
            var type = obj[i]["type"]
            await readJSONAndAssignLevels(path, method, obj[i], indent + '.' + i, i, treeLevel, type);
        } else {
            var typeOfObject = obj[i].toString();
            if (!(typeOfObject === "object" || typeOfObject === "array" || typeOfObject.includes("#/definitions") || typeOfObject.indexOf(' ') >= 0 || typeof type === "undefined")) {
               var data;
               /* Previous Code  */
                // jsonSourceArray.push(path + ":" + method + ":" + "JSON.Data" + indent.trim() + "." + type);
               /* New Code for extracting parameters and their datatypes separated by :*/
               data = indent.substring(3,indent.length)
               jsonDataArr= {[data]:type}; 
            }
        }
    }
    console.log("SHOW JSON ARRAY :: ",jsonDataArr);
    return jsonSourceArray;
}

async function removeParameterAndItem(array) {
    var eachRecord;
    for (var data of array) {
        eachRecord = data.split(".");
        for (var j = 0; j < eachRecord.length; j++) {
            if (eachRecord[j] === eachRecord[j + 1]) {
                if (eachRecord[j] === "properties" || eachRecord[j] === "items") {
                    eachRecord.splice(parseInt(j), 1);
                }
            } else {
                if (eachRecord[j] === "properties" || eachRecord[j] === "items") {
                    eachRecord.splice(j, 1);
                    j = j - 1;
                }
            }
            if (eachRecord[j].toString() === "Data") {
                var numPattern = new RegExp(/^[0-9]*$/)
                var check = numPattern.test(eachRecord[j + 1])
                if (check) {
                    eachRecord.splice(j + 1, 1);
                }
            }
        }
        values = eachRecord.join('.')
        esqlData.push(values);
    }
}


// Convert data to JSON format for ESQL Data
async function transformEachRecord(data) {
    var transformedArray = [];
    var jsonData = {};

    for (var eachRecord of data) {
        var splitByColon = eachRecord.split(":")
        // console.log(splitByColon)
        var splitByDot = splitByColon[2].split(".")
        var name = splitByColon[2].substr(0, splitByColon[2].lastIndexOf("."))
        if (name !== "JSON.Data"){
            jsonData["path"] = splitByColon[0];
            jsonData["method"] = splitByColon[1]
            jsonData["name"] = name;
            jsonData["type"] = splitByDot[splitByDot.length - 1];
            transformedArray.push(jsonData)
            jsonData = {};
        }
    }
    return transformedArray;
}

module.exports.extractPathsAndMethods = extractPathsAndMethods