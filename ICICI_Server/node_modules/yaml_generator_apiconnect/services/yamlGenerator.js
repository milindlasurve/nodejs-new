
const yaml = require('js-yaml')
const fs = require('fs')
var q = require('q');

//Source File
var template;
//Target File
var fileName;


statusCode = {
	200: {
		description: '200 OK'
	},
	401: {
		description: 'Unauthorized'
	},
	402: {
		description: 'Parameters where valid but request failed'
	},
	404: {
		description: 'Resource not found'
	},
	429: {
		description: 'Too many request'
	},
	503: {
		description: 'Service Unavailable'
	}
}



var requestBody =
	[
		{
			name: 'Request',
			required: true,
			in: 'body',
			name: 'body',
			schema: {
				$ref: '#/definitions/Request'
			}
		}
	];

var responseCode = "200"
var responseBody =
	{

		description: '200 OK',
		schema: {
			$ref: '#/definitions/Response'

		}
	}
var title, x_ibm_name, basePath;
var target_url, paths;
var methods = [];
var data;


/**
 * 
 * @param {*} template 
 * @param {*} data 
 * @param {*} fileName 
 * @description Generates a new YAML file using a template file and Parameters 
 */
async function generateYaml(template, data, fileName) {

	var deferred = q.defer();
	try {

		// Convert YAML to JSON
		var doc = await convertYaml(template);
		console.log("Data : ", JSON.stringify(doc))

		// Swagger Title target-url ..
		var metaData = await generateMetadata(doc, data)
		console.log(JSON.stringify(metaData));

		var pathData = await generatePaths(doc, data, data.path);
		console.log("Path Data : ", JSON.stringify(pathData));

		createYaml(doc, fileName, function (err, writeFile) {
			if (err) throw err;
			console.log("Result ::: ", writeFile);
			deferred.resolve(writeFile);
		});
		console.log(JSON.stringify(doc));
	}
	catch (e) {
		console.log("Error ::: ", e);
		deferred.reject({ "Error": e });
	}
	return deferred.promise;
}

/**
 * 
 * @param {*} doc 
 * @description converts a YAML data to JSON object
 */
async function convertYaml(doc) {
	try {
		doc = yaml.safeLoad(fs.readFileSync(doc, 'utf8'));
		console.log(doc);
		return doc;
	} catch (e) { throw e; }

}

//async function generateMetadata(title,ibmName,basePath,targetUrl,targetUrlDescription,sandboxTargetUrl){
/**
 * 
 * @param {*} doc 
 * @param {*} data
 * @description Generates Metadata for YAML file. For eg: Title, description etc. 
 */
async function generateMetadata(doc, data) {

	try {
		doc.info.title = data.title;
		doc.info['x-ibm-name'] = data.title;//Changed from ibmName to title
		doc.basePath = data.basePath;
		doc['x-ibm-configuration'].assembly.execute[0].invoke['target-url'] = data.targetUrl;
		//doc['x-ibm-configuration'].properties['target-url'].value=data.targetUrl;
		return doc;
	} catch (e) { throw e; }
}

/**
 * 
 * @param {*} doc 
 * @param {*} data 
 * @param {*} path 
 * @description generates path data
 */
async function generatePaths(doc, data, path) {

	try {
		var param = [];
		// If request data contains more data other than post body
		//Needs Work
		for (var i = 0; i < (data.operations[0].fields).length; i++) {

			param.push(data.operations[0].fields[i]);

		}

		var method = await createMethods(data.operations, doc, param);

		console.log("PAth :: ",path)
		doc.paths = {
			[path]:
				method
		}

		doc.definitions.Request.properties = data.operations[0].fields[0];


		return doc.paths
	}
	catch (e) { throw e; }

}

/* Creates Methods and according to the method type generates parameters*/
/**
 * 
 * @param {*} methods 
 * @param {*} doc 
 * @param {*} param
 * @description Generates Method
 *  
 */
async function createMethods(methods, doc, param) {

	try {
		//var 
		for (var i = 0; i < methods.length; i++) {
			console.log("Methods: ", methods[i].method);


			if (methods[i].method.toString() == "post") {
				var response;
				if (methods[i].responses != "") {
					console.log("Test Inside")
					response = methods[i].responses[0]['200'];
					console.log("Responses :::: ",response);
				}
				else {

					response = "";

				}
				return await createParamsForPost(methods[i].fields[0], response, doc, param);
			}
			else {

				// for GET, PUT etc.

			}
		}
	}
	catch (e) { throw e; }

}

/**
 * 
 * @param {*} parameters 
 * @param {*} responses 
 * @param {*} doc 
 * @param {*} param 
 * @description Creates parameter data for POST method
 */
async function createParamsForPost(parameters, responses, doc, param) {


	try {

		var parametersOtherThanPost = [];

		// Add schema Definition if 200 contains response parameters
		if (responses) {
			statusCode = await createResponseForPost(responses, doc);
		}
		var methods = "{\"post\":{\"responses\":" + JSON.stringify(statusCode) + ",\"parameters\":" + JSON.stringify(requestBody) + "}}";
		console.log("Methods Stringify:::  ", methods);
		return JSON.parse(methods);
	}
	catch (e) { throw e; }
}

/**
 * 
 * @param {*} responses 
 * @param {*} doc
 * @description Generates Response data for POST method 
 */
async function createResponseForPost(responses, doc) {

	try {
		statusCode['200'] = responseBody;

		var properties = responses;

		console.log("Response ::: ", statusCode);
		doc.definitions.Response = {
			description: "",
			type: "object",
			properties
		};


		return statusCode;
	}
	catch (e) { throw e; }
}

//Generate the APIConnect YAML from the
/**
 * 
 * @param {*} doc 
 * @param {*} fileName 
 * @description Generates the YAML file
 */
async function createYaml(doc, fileName, callback) {

	try {
		console.log("Inside Create YAML : ", JSON.stringify(doc))
		fs.writeFile(fileName, yaml.safeDump(doc), 'utf8', function (err) {
			if (err) throw err;
			callback(null, "File generated");
		});
	}
	catch (e) { throw e; }
}

module.exports.genYaml = generateYaml
