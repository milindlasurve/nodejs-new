
var fs = require('fs');
var q = require("q");

// Source matlab client

// to put data into db
/*  */
async function createEsqlStatusCheck(template, parameters, fileName) {

	var deferred = q.defer();
	try {
		// fieldValues = parameters.fields;
		// sourceType = parameters.sourceType;
		// targetType = parameters.targetType;


		// Check for Validation Status target and add the field to the esql if condition
		var returnValidationStatusInfo = await searchValidationStatus(parameters.fields);
		console.log("Validation Status Info ::: ", returnValidationStatusInfo);
		//console.log("SHOW PARAMS ::: ", returnParameterDefinitions);
		if (returnValidationStatusInfo) {

			readContent(template, fileName, async function (err, content) {
				if (err) throw new Error("Could not read the Template. Reason : " + err);
				//console.log("Read Content ::: ",content)

				if (content) {



					/* Combine mapping data in the template file */
					//var result =  await writeContent(content,returnParameterDefinitions,"-- Code --","");
					var result = await writeContent(content, returnValidationStatusInfo, "-- Change --", "all")
					//console.log("Result ::: ", result);

					generateFile(fileName, result, function (err, writeFile) {
						if (err) throw new Error("Could not generate ESQL. Reason : " + err);
					//	console.log("Result ::: ", writeFile);
						deferred.resolve(writeFile);

					});



				}
			})
		}
	}
	catch (e) {
		//console.error(e);
		deferred.reject(e)
	}

	return deferred.promise;
}






/* Set Preset based on the Side eg: LHS or RHS*/


/**
 * 
 * @param {*} template 
 * @param {*} fileName 
 * @param {*} callback 
 * 
 * @description Read a file
 */
function readContent(template, fileName, callback) {

	fs.readFile(template, 'utf8', function (err, data) {
		if (err) {
			throw err;
		}
		callback(null, data);

	});
}



/**
 * 
 * @param {*} result 
 * @param {*} fileName 
 * @param {*} callback
 * 
 * @description Write contents to a file 
 */
async function writeContent(content, data, replaceTag, replaceWithTag) {
	var result = "";
	if (replaceWithTag)
		result = replaceAll(content, replaceTag, data);
	else
		result = content.replace(replaceTag, replaceTag + "\n" + data);
	return result;

}

function generateFile(fileName, result, callback) {
	fs.writeFile(fileName, result, 'utf8', function (err) {
		if (err) throw err;
		callback(null, "File generated");
	});
}

/**
 * 
 * @param {*} param
 * @description removes items and properties to convert array from JSON to ESQL 
 */
async function removeItemsAndProperties(param) {
	var value = "";
	for (var i = 0; i < param.length; i++) {
		if (param[i] === "items") {
			param[i] = "item";
		} else if (param[i] === "properties") {

			param.shift();
		}
		value += "\"" + param[i] + "\"";
	}
	value = replaceAll(value, "\"\"", "\".\"")
	return value;
}

/**
 * 
 * @param {*} fields
 * @description search for ValidationStatus and create code for esql file 
 */
async function searchValidationStatus(fields) {
	console.log("FIELDS ::: ", fields);
	var source = "";
	var target = "";
	for (var i = 0; i < fields.length; i++) {
		source = fields[i].source;
		target = fields[i].target;

		if (source === "ValidationStatus") {
			console.log("SOURCE INSIDE ")
			values = target.split(".");
			return await removeItemsAndProperties(values);
		}
		// Included this code on 11-09-2019. Checl
		else{
			values = target.split(".");
			return await removeItemsAndProperties(values);
		}
	}

}


// Replace an occurrence repeatedly
function replaceAll(str, find, replace) {
	return str.replace(new RegExp(find, 'g'), replace);
}

module.exports.createEsqlStatusCheck = createEsqlStatusCheck