
var fs = require('fs');
var q = require("q");
var fileName = "";

// Source matlab client



// to put data into db
var dbName = "";

var sourceType;
var targetType;
var fieldsValues;
var arrayName;

var template = ""

//console.log(sourceType)
//console.log(targetType)
//createEsql(template,parameters,fileName)

/**
 * 
 * @param {*} template 
 * @param {*} parameters 
 * @param {*} fileName 
 * @description Generates an ESQL File for Accept and Reject Scenarios 
 */
async function createEsqlReject(template, parameters, fileName) {

	var deferred = q.defer();
	try {
		fieldValues = parameters.fields;
		sourceType = parameters.sourceType;
		targetType = parameters.targetType;

		var returnParameterDefinitions = await createParameterDefinitions(fieldValues, sourceType, targetType);
		var returnFieldDefinitions = await createFieldDefinitions(parameters.fieldDefinitions);

		// Check for Validation Status target and add the field to the esql if condition
		var returnValidationStatusInfo = await searchValidationStatus(parameters.fields);
		//console.log("Validation Status Info ::: ",returnValidationStatusInfo);
		//console.log("SHOW PARAMS ::: ", returnParameterDefinitions);
		if (returnParameterDefinitions) {

			readContent(template, fileName, async function (err, content) {
				if (err) return "Could not read the Template. Reason : " + err;
				console.log("Read Content ::: ",content)

				if (content) {

					//copycontent(template,fileName,async function (err, copyData) {
					if (err) throw new Error("Could not copy the Template. Reason : " + err);
					//console.log("Copy Content ::: ",copyData);

					//if(copyData){

					/* Combine mapping data in the template file */
					var result = await writeContent(content, returnParameterDefinitions, "-- Code --", "");
					result = await writeContent(result, returnValidationStatusInfo, "-- Change --", "all")
					console.log("Result Write 1::: ", result);

					generateFile(fileName, result, function (err, writeFile) {
						if (err) throw new Error("Could not generate ESQL. Reason : " + err);;
						console.log("Result ::: ",writeFile);
						deferred.resolve(writeFile);

					});

					//	}
					//});

				}
			})
		}
	}
	catch (e) {
		//console.error(e);
		deferred.reject(e);
		//return "Failed : "+e;
	}
	return deferred.promise;
}

/**
 * 
 * @param {*} parameters 
 * @param {*} sourceType 
 * @param {*} targetType
 * @description Combines data of LHS and RHS for ESQL file 
 */
async function createParameterDefinitions(parameters, sourceType, targetType) {

	var esqlLHSValues = [];
	var esqlRHSValues = [];
	var values;
	var preset;
	// Capture Values for LHS

	try {
		for (var i in parameters) {
			//console.log("Value : ",parameters[i].source);

			values = (parameters[i].source).split(".");

			//Call the function 
			esqlLHSValues.push(await setLHSValue(values, sourceType));
		}

		// Capture Values for RHS
		for (var i in parameters) {
			//console.log("RHS Value : ",parameters[i].target);
			values = (parameters[i].target).split(".");

			esqlRHSValues.push(await setRHSValue(values, targetType, parameters[i].operation));
		}

		//console.log(esqlLHSValues);
		//console.log(esqlRHSValues);

		var result = [esqlLHSValues, esqlRHSValues].reduce((a, b) => a.map((v, i) => v + "=" + b[i]));
		var res = "";

		for (var i in result) {
			res += result[i] + "\n";
		}
		//console.log(res);
		return res;
	}
	catch (e) { throw e; }
}

/**
 * 
 * @param {*} param 
 * @param {*} type
 * @description Generates LHS values 
 */
async function setLHSValue(param, type) {

	var value = "";
	var preset = "";

	try {

		value = await removeItemsAndProperties(param);
		//console.log("Split Value : ",value);
		if (type === "JSON") {
			preset = "SET OutputRoot.JSON.Data.";
		}
		else if (type === "DFDL") {
			preset = "SET OutputRoot.DFDL.ns1:REL_AcceptReject.record."
		}
		else if (type === "Environment.JSON") {
			preset = "SET Environment.Variables.JSON.Data.";
		}
		else if (type === "XML") {
			preset = "SET OutputRoot.XMLNSC.BANK.";
		}
		return preset + value;

		// Splitting and again setting the dot (.) . But working only for the first time. Check
	}
	catch (e) { throw e; }
}

/**
 * 
 * @param {*} param 
 * @param {*} type 
 * @param {*} operation
 * @description Generates RHS values 
 */
async function setRHSValue(param, type, operation) {
	//console.log("Param :: ",param);
	var value = "";
	var preset = "";
	var result = "";
	try {

		value = await removeItemsAndProperties(param);

		if (type === "DFDL") {
			preset = " InputRoot.DFDL.ns1:REL_Input.record."
		}
		else if (type === "JSON") {
			preset = " InputRoot.JSON.Data.";
		}
		else if (type === "Environment.JSON") {
			preset = " Environment.Variables.JSON.Data.";
		}
		else if (type === "XML") {
			preset = " InputRoot.XMLNSC.BANK.";
		}
		result = preset + value + ";"
		if (operation === "coalesce") {
			result = "COALESCE(" + preset + value + ",'Reason not Specified');";
		}
		else if (operation === "CAST:INTEGER") {
			//console.log("Inside CAST INTEGER");
			//console.log("PRESET ::", preset);
			//console.log("VALUE :: ", value);
			result = "CAST(" + preset + value + " AS INTEGER CCSID 1208);";
		}
		//console.log("RESULT ::: ", result);
		return result;
	}
	catch (e) { throw e; }
}

/**
 * 
 * @param {*} fieldDefinitions
 * @description Generate Field Definitions in ESQL for Source and Target eg: Array 
 */
async function createFieldDefinitions(fieldDefinitions) {
	var result = "";

	var fieldName;
	var fieldType;
	var format;
	var preset;

	////console.log("FIELD DEFINITIONS ::: ", fieldDefinitions);
	for (let i = 0; i < fieldDefinitions.length; i++) {
		fieldName = fieldDefinitions[i].fieldName;
		fieldType = fieldDefinitions[i].fieldType;
		format = fieldDefinitions[i].format;
		preset = fieldDefinitions[i].preset;

		esqlPreset = await setPreset(preset);
		esqlFormat = await setFormat(format);
		esqlFieldType = format + "." + fieldType;

		result += "CREATE FIELD " + esqlPreset + "." + esqlFormat + ".\"" + fieldName + "\" IDENTITY(" + esqlFieldType + ") \"" + fieldName + "\"\n";
		//console.log("RESULT :::: ",result);
		//"CREATE FIELD OutputRoot.JSON.Data."Virtual Account Number Verification IN" IDENTITY(JSON.Array) "Virtual Account Number Verification IN""

		//console.log("***********888 :",fieldName)
		//console.log("**************8 :",fieldType)
		//console.log("************88 :",format)
		//console.log("**********88888  :",preset)

	}
	return result;
}


/**
 * 
 * @param {*} preset
 * @description Set Preset based on the Side eg: LHS or RHS 
 */
async function setPreset(preset) {
	try {

		if (preset === "source") {
			return "OutputRoot";
		}
		else if (preset === "target") {
			return "InputRoot";
		}
	} catch (e) {
		throw e;
	}

}

/**
 * 
 * @param {*} format
 * 
 */
async function setFormat(format) {

	try {
		if (format === "JSON") {
			return "JSON.Data"
		} else if (format === "DFDL") {
			return "DFDL.ns1:REL_AcceptReject.record"
		}
		else if (type === "Environment.JSON") {
			return "Environment.Variables.JSON.Data.";
		}
	} catch (e) {
		throw e;
	}

}

/**
 * 
 * @param {*} preset 
 * @param {*} fieldType 
 * @description sets the field type
 */
async function setFieldType(preset, fieldType) {

	try {
		if (preset === "JSON") {
			if (fieldType === "array") {
				return preset.fieldType
			}
		}
	} catch (e) {
		throw e;
	}

}

/**
 * 
 * @param {*} template 
 * @param {*} fileName 
 * @param {*} callback 
 * 
 * @description Read a file
 */
function readContent(template, fileName, callback) {

	fs.readFile(template, 'utf8', function (err, data) {
		if (err) {
			throw err;
		}
		callback(null, data);

	});
}

/**
 * 
 * @param {*} template 
 * @param {*} fileName 
 * @param {*} callback 
 * 
 * @description Copy a file content to another file
 */
async function copycontent(template, fileName, callback) {

	fs.copyFile(template, fileName, (err) => {
		if (err) throw err;
		console.log('source.txt was copied to destination.txt');
		callback(null, "Success");
	});

}


/**
 * 
 * @param {*} result 
 * @param {*} fileName 
 * @param {*} replaceTag
 * @param {*} replaceWithTag
 * 
 * @description Write contents to a file 
 */
async function writeContent(content, data, replaceTag, replaceWithTag) {
	var result = "";
	if (replaceWithTag)
		result = replaceAll(content, replaceTag, data);
	else
		result = content.replace(replaceTag, replaceTag + "\n" + data);
	return result;

}

/**
 * 
 * @param {*} fileName 
 * @param {*} result 
 * @param {*} callback
 * @description Generates the File based on the parameters. 
 * Callback is used to return the status  
 */
function generateFile(fileName, result, callback) {
	fs.writeFile(fileName, result, 'utf8', function (err) {
		if (err) throw err;
		callback(null, "File generated");
	});
}

/**
 * 
 * @param {*} param
 * @description removes items and properties to convert array from JSON to ESQL 
 */
async function removeItemsAndProperties(param) {
	var value = "";
	for (var i = 0; i < param.length; i++) {
		if (param[i] === "items") {
			param[i] = "item";
		} else if (param[i] === "properties") {

			param.shift();
		}
		value += "\"" + param[i] + "\"";
	}
	value = replaceAll(value, "\"\"", "\".\"")
	return value;
}

/**
 * 
 * @param {*} fields
 * @description search for ValidationStatus and create code for esql file 
 */
async function searchValidationStatus(fields) {

	var source = "";
	var target = "";
	for (var i = 0; i < fields.length; i++) {
		source = fields[i].source;
		target = fields[i].target;

		if (source === "ValidationStatus") {
			values = target.split(".");
			return await removeItemsAndProperties(values);
		}
	}

}

/** 
 * 
 * @param {*} str
 * @param {*} find
 * @param {*} replace
 * @description Replaces all the occurence of a character or word
 * */
function replaceAll(str, find, replace) {
	return str.replace(new RegExp(find, 'g'), replace);
}

module.exports.createEsqlReject = createEsqlReject